package com.gilia.builder.jsontranslator;

import com.gilia.exceptions.AlreadyExistException;
import com.gilia.exceptions.EntityNotValidException;
import com.gilia.exceptions.InformationNotFoundException;
import com.gilia.metamodel.Metamodel;
import com.gilia.metamodel.constraint.CompletenessConstraint;
import com.gilia.metamodel.constraint.cardinality.ObjectTypeCardinality;
import com.gilia.metamodel.constraint.disjointness.DisjointObjectType;
import com.gilia.metamodel.constraint.mandatory.Mandatory;
import com.gilia.metamodel.entitytype.EntityType;
import com.gilia.metamodel.entitytype.objecttype.ObjectType;
import com.gilia.metamodel.relationship.Relationship;
import com.gilia.metamodel.relationship.Subsumption;
import com.gilia.metamodel.role.Role;
import org.apache.commons.lang3.StringUtils;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import java.util.ArrayList;

import static com.gilia.utils.Constants.*;

/**
 * Represents a concrete builder in the Builder design pattern.
 * This class is in charge of building the Metamodel instance according to a Metamodel JSON.
 */
public class MetaTranslator implements JSONTranslator {

    @Override
    public Metamodel createMetamodel(JSONObject json) {
        String ontologyIRI = "";
        try {
            ontologyIRI = (String) ((JSONObject) ((JSONObject) json.get(KEY_NAMESPACES)).get(KEY_ONTOLOGY_IRI)).get(KEY_VALUE);
        } catch (NullPointerException | ClassCastException e) {
            System.out.println("WARNING: ontologyIRI was not obtained");
        }

        Metamodel newMetamodel = new Metamodel(ontologyIRI);
        JSONObject jsonEntities = (JSONObject) json.get(StringUtils.capitalize(KEY_ENTITY_TYPE));
        JSONArray jsonObjectTypes = (JSONArray) jsonEntities.get(StringUtils.capitalize(KEY_OBJECT_TYPE));

        JSONObject jsonRelationships = (JSONObject) json.get(StringUtils.capitalize(RELATIONSHIP_STRING));
        JSONArray jsonBinaryRelationships = (JSONArray) jsonRelationships.get(StringUtils.capitalize(RELATIONSHIP_STRING));
        JSONArray jsonSubsumptions = (JSONArray) jsonRelationships.get(StringUtils.capitalize(SUBSUMPTION_STRING));

        JSONArray jsonRoles = (JSONArray) json.get(StringUtils.capitalize(ROLE_STRING));
        JSONObject jsonConstraints = (JSONObject) json.get(StringUtils.capitalize(KEY_CONSTRAINTS));

        // The order of this calls is important (at least for now)
        identifyObjectTypes(newMetamodel, jsonObjectTypes);
        identifyRelationships(newMetamodel, jsonBinaryRelationships); // Does not include subsumptions, roles, nor constraints
        identifyConstraints(newMetamodel, jsonConstraints);
        identifyRoles(newMetamodel, jsonRoles);
        identifySubclasses(newMetamodel, jsonSubsumptions);

        return newMetamodel;
    }

    /**
     * Identifies each class from a JSONArray of entities obtained from the Metamodel JSON and generates every object type given.
     * After identifying each object type, it generates the corresponding metamodel class and incorporates it to the metamodel instance.
     *
     * @param model           Metamodel instance that will incorporate the object types generated by this method
     * @param jsonObjectTypes JSONArray with the name of the entities represented within the model.
     */
    private void identifyObjectTypes(Metamodel model, JSONArray jsonObjectTypes) {
        if (jsonObjectTypes != null) {
            ArrayList newObjectsType = new ArrayList();
            for (Object metaObjectType : jsonObjectTypes) {
                String entityName = (String) metaObjectType;
                if (model.checkEntityExistence(entityName) == null) {
                    ObjectType newObjectType = new ObjectType(entityName);
                    newObjectsType.add(newObjectType);
                } else {
                    throw new AlreadyExistException(ALREADY_EXIST_ENTITY_ERROR);
                }
            }
            model.addEntities(newObjectsType);
        } else {
            throw new InformationNotFoundException(ENTITIES_INFORMATION_NOT_FOUND_ERROR);
        }
    }

    /**
     * Identifies each relationship from a JSONArray of relationships obtained from the Metamodel JSON and generates every relationship.
     * It generates the corresponding metamodel class and incorporates it to the metamodel instance.
     *
     * @param model             Metamodel instance that will incorporate the relationships generated by this method.
     * @param jsonRelationships JSONArray with the objects that represents each relationship within the model.
     */
    private void identifyRelationships(Metamodel model, JSONArray jsonRelationships) {
        if (jsonRelationships != null) {
            ArrayList newRelationships = new ArrayList();
            for (Object metaRelationship : jsonRelationships) {
                String relationshipName = (String) ((JSONObject) metaRelationship).get(KEY_NAME);
                JSONArray entities = (JSONArray) ((JSONObject) metaRelationship).get(KEY_ENTITIES);
                ArrayList objectTypesInvolved = new ArrayList();
                for (Object entity : entities) {
                    String entityName = (String) entity;
                    ObjectType entityInvolved = (ObjectType) model.checkEntityExistence(entityName);
                    if (entityInvolved != null) {
                        objectTypesInvolved.add(entityInvolved);
                    } else {
                        throw new EntityNotValidException(ENTITY_NOT_FOUND_ERROR);
                    }
                }
                Relationship newRelationship = new Relationship(relationshipName, objectTypesInvolved);
                newRelationships.add(newRelationship);
            }
            model.addRelationships(newRelationships);
        } else {
            throw new InformationNotFoundException(RELATIONSHIPS_INFORMATION_NOT_FOUND_ERROR);
        }
    }

    private void identifyConstraints(Metamodel model, JSONObject jsonConstraints) {
        if (jsonConstraints != null) {
            // Completeness
            JSONArray jsonCompletenessConstraints = (JSONArray) jsonConstraints.get(StringUtils.capitalize(KEY_COMPLETENESS_CONSTRAINT));
            identifyCompletenessConstraints(model, jsonCompletenessConstraints);

            // Cardinality
            JSONObject jsonCardinalityConstraints = (JSONObject) jsonConstraints.get(StringUtils.capitalize(KEY_CARDINALITY_CONSTRAINTS));
            JSONArray jsonObjectTypeCardinalityConstraints = (JSONArray) jsonCardinalityConstraints.get(StringUtils.capitalize(KEY_OBJECT_TYPE_CARDINALITY));
            identifyObjectTypeCardinalityConstraints(model, jsonObjectTypeCardinalityConstraints);

            // Disjointness
            JSONObject jsonDisjointnessConstraints = (JSONObject) jsonConstraints.get(StringUtils.capitalize(KEY_DISJOINTNESS_CONSTRAINT));
            JSONArray jsonDisjointObjectTypeConstraints = (JSONArray) jsonDisjointnessConstraints.get(StringUtils.capitalize(KEY_DISJOINT_OBJECT_TYPE_CONSTRAINT));
            identifyDisjointObjectTypeConstraints(model, jsonDisjointObjectTypeConstraints);

            // Mandatory
            JSONObject jsonMandatoryConstraints = (JSONObject) jsonConstraints.get(StringUtils.capitalize(KEY_MANDATORY_CONSTRAINTS));
            JSONArray jsonMandatory = (JSONArray) jsonMandatoryConstraints.get(StringUtils.capitalize(KEY_MANDATORY));
            identifyMandatory(model, jsonMandatory);
        } else {
            throw new InformationNotFoundException(CONSTRAINTS_INFORMATION_NOT_FOUND_ERROR);
        }
    }

    private void identifyMandatory(Metamodel model, JSONArray jsonMandatory) {
        if (model != null && jsonMandatory != null) {
            for (Object mandatory : jsonMandatory) {
                JSONObject mandatoryConstraint = (JSONObject) mandatory;
                Mandatory newMandatory = new Mandatory((String) mandatoryConstraint.get(KEY_NAME));
                model.addConstraint(newMandatory);
            }
        }
    }

    private void identifyObjectTypeCardinalityConstraints(Metamodel model, JSONArray jsonCardinalities) {
        if (model != null && jsonCardinalities != null) {
            for (Object constraint : jsonCardinalities) {
                JSONObject cardinalityConstraint = (JSONObject) constraint;
                String constraintName = (String) cardinalityConstraint.get(KEY_NAME);
                String minimum = (String) cardinalityConstraint.get(KEY_MINIMUM);
                String maximum = (String) cardinalityConstraint.get(KEY_MAXIMUM);
                ObjectTypeCardinality newCardinality = new ObjectTypeCardinality(constraintName, minimum, maximum);
                model.addConstraint(newCardinality);
            }
        }
    }

    private void identifyCompletenessConstraints(Metamodel model, JSONArray jsonConstraints) {
        if (model != null && jsonConstraints != null) {
            for (Object constraint : jsonConstraints) {
                JSONObject completenessConstraint = (JSONObject) constraint;
                String constraintName = (String) completenessConstraint.get(KEY_NAME);
                JSONArray entities = (JSONArray) completenessConstraint.get(KEY_ENTITIES);
                ArrayList objectTypesInvolved = new ArrayList();
                for (Object entity : entities) {
                    String entityName = (String) entity;
                    ObjectType objectType = (ObjectType) model.checkEntityExistence(entityName);
                    if (objectType != null) {
                        objectTypesInvolved.add(objectType);
                    } else {
                        throw new EntityNotValidException(ENTITY_NOT_FOUND_ERROR);
                    }
                }
                CompletenessConstraint newConstraint = new CompletenessConstraint(constraintName, objectTypesInvolved);
                model.addConstraint(newConstraint);
            }
        }
    }

    private void identifyDisjointObjectTypeConstraints(Metamodel model, JSONArray jsonConstraints) {
        if (model != null && jsonConstraints != null) {
            for (Object constraint : jsonConstraints) {
                JSONObject disjointnessConstraint = (JSONObject) constraint;
                String constraintName = (String) disjointnessConstraint.get(KEY_NAME);
                JSONArray entities = (JSONArray) disjointnessConstraint.get(KEY_ENTITIES);
                ArrayList objectTypesInvolved = new ArrayList();
                for (Object entity : entities) {
                    String entityName = (String) entity;
                    ObjectType objectType = (ObjectType) model.checkEntityExistence(entityName);
                    if (objectType != null) {
                        objectTypesInvolved.add(objectType);
                    } else {
                        throw new EntityNotValidException(ENTITY_NOT_FOUND_ERROR);
                    }
                }
                DisjointObjectType newConstraint = new DisjointObjectType(constraintName, objectTypesInvolved);
                model.addConstraint(newConstraint);
            }
        }
    }

    private void identifyRoles(Metamodel model, JSONArray jsonRoles) {
        if (model != null && jsonRoles != null) {
            for (Object role : jsonRoles) {
                JSONObject jsonRole = (JSONObject) role;
                String roleName = (String) jsonRole.get(KEY_ROLENAME);
                String relationshipName = (String) jsonRole.get(RELATIONSHIP_STRING);
                String entityName = (String) jsonRole.get(KEY_ENTITY_TYPE);
                JSONArray cardinalities = (JSONArray) jsonRole.get(KEY_OBJECT_TYPE_CARDINALITY);
                String mandatory = (String) jsonRole.get(KEY_MANDATORY);

                Relationship relationshipInvolved = (Relationship) model.checkEntityExistence(relationshipName);
                EntityType entityInvolved = (EntityType) model.checkEntityExistence(entityName);

                if (relationshipInvolved == null || entityInvolved == null) {
                    throw new EntityNotValidException(ENTITY_NOT_FOUND_ERROR);
                }

                ArrayList cardinalitiesInvolved = new ArrayList();
                for (Object cardinality : cardinalities) {
                    String cardinalityName = (String) cardinality;
                    ObjectTypeCardinality cardinalityInvolved = (ObjectTypeCardinality) model.checkEntityExistence(cardinalityName);
                    if (cardinalityInvolved != null) {
                        cardinalitiesInvolved.add(cardinalityInvolved);
                    } else {
                        throw new EntityNotValidException(ENTITY_NOT_FOUND_ERROR);
                    }
                }

                Mandatory mandatoryInvolved = null;
                if (mandatory != null) {
                    mandatoryInvolved = (Mandatory) model.checkEntityExistence(mandatory);
                }
                Role newRole = new Role(roleName, entityInvolved, relationshipInvolved, cardinalitiesInvolved, mandatoryInvolved);
                relationshipInvolved.addRole(newRole);
                if (mandatory != null && mandatoryInvolved != null) {
                    mandatoryInvolved.setDeclaredOn(newRole);
                }
                model.addRole(newRole);
            }
        } else {
            throw new InformationNotFoundException(ROLES_INFORMATION_NOT_FOUND_ERROR);
        }
    }

    private void identifySubclasses(Metamodel model, JSONArray jsonSubsumptions) {
        if (model != null && jsonSubsumptions != null) {
            for (Object metaSubsumption : jsonSubsumptions) {
                String subsumptionName = (String) ((JSONObject) metaSubsumption).get(KEY_NAME);
                String parentName = (String) ((JSONObject) metaSubsumption).get(KEY_ENTITY_PARENT);
                String childName = (String) ((JSONObject) metaSubsumption).get(KEY_ENTITY_CHILD);
                String disjointnessName = (String) ((JSONObject) metaSubsumption).get(KEY_DISJOINTNESS_CONSTRAINT);
                String completenessName = (String) ((JSONObject) metaSubsumption).get(KEY_COMPLETENESS_CONSTRAINT);

                ObjectType parentInvolved = (ObjectType) model.checkEntityExistence(parentName);
                ObjectType childInvolved = (ObjectType) model.checkEntityExistence(childName);

                if (parentInvolved == null || childInvolved == null) {
                    throw new EntityNotValidException(ENTITY_NOT_FOUND_ERROR);
                }

                ArrayList constraintsInvolved = new ArrayList();
                if (disjointnessName != null) {
                    DisjointObjectType disjointnessConstraint = (DisjointObjectType) model.checkEntityExistence(disjointnessName);
                    if (disjointnessConstraint == null) {
                        throw new EntityNotValidException(ENTITY_NOT_FOUND_ERROR);
                    }
                    constraintsInvolved.add(disjointnessConstraint);
                }
                if (completenessName != null) {
                    CompletenessConstraint completenessConstraint = (CompletenessConstraint) model.checkEntityExistence(completenessName);
                    if (completenessConstraint == null) {
                        throw new EntityNotValidException(ENTITY_NOT_FOUND_ERROR);
                    }
                    constraintsInvolved.add(completenessConstraint);
                }

                Subsumption newSubsumption = new Subsumption(subsumptionName, parentInvolved, childInvolved, constraintsInvolved);
                model.addRelationship(newSubsumption);
            }
        } else {
            throw new InformationNotFoundException(RELATIONSHIPS_INFORMATION_NOT_FOUND_ERROR);
        }
    }

}
